import { loadStripe, Stripe, StripeCardElement } from '@stripe/stripe-js';
import { toast } from 'react-hot-toast';
// In a real app, you would use your configured API client (e.g., from RTK Query)
// For this example, we'll simulate the fetch call.
// import { api } from './api';

// --- Types and Enums ---

/**
 * Defines the supported payment gateways.
 */
export enum SupportedGateway {
  STRIPE = 'STRIPE',
  PAYHERE = 'PAYHERE',
}

/**
 * Payload required by the backend to create a payment intent.
 */
export interface PaymentIntentPayload {
  rideId?: string; // For ride payments
  walletTopUpAmount?: number; // For wallet top-ups
  currency: 'LKR' | 'USD';
  gateway: SupportedGateway;
}

/**
 * The expected response from the YALURIDE backend after creating a payment intent.
 */
export interface BackendPaymentIntentResponse {
  provider: SupportedGateway;
  paymentIntentId: string; // YALURIDE's internal transaction ID
  clientSecret?: string; // Specific to Stripe
  // --- PayHere Specific Properties ---
  merchantId?: string;
  orderId?: string;
  amount?: number;
  currency?: string;
  hash?: string; // Security hash generated by the backend for PayHere
}

/**
 * Standardized result object after a frontend payment confirmation attempt.
 */
export interface PaymentConfirmationResult {
  success: boolean;
  paymentIntentId?: string; // Stripe's payment intent ID
  orderId?: string; // PayHere's order ID
  error?: {
    code?: string;
    message: string;
  };
}

// --- Service Implementation ---

class PaymentGatewayService {
  private stripePromise: Promise<Stripe | null> | null = null;

  constructor() {
    // Initialize Stripe.js lazily to avoid loading the script unnecessarily.
    const stripePublicKey = import.meta.env.VITE_STRIPE_PUBLIC_KEY;
    if (stripePublicKey) {
      this.stripePromise = loadStripe(stripePublicKey);
    } else {
      console.warn('Stripe public key (VITE_STRIPE_PUBLIC_KEY) is not configured. Stripe payments will be unavailable.');
    }
  }

  /**
   * Creates a payment intent on the YALURIDE backend.
   * This is the first step for any card-based payment.
   * @param payload - The details of the payment to be initiated.
   * @returns A promise that resolves with the backend's response, containing gateway-specific info.
   */
  public async createPaymentIntent(payload: PaymentIntentPayload): Promise<BackendPaymentIntentResponse> {
    try {
      // In a real application, this would be a call using your API client, e.g., an RTK Query mutation.
      // const response = await dispatch(api.endpoints.createPaymentIntent.initiate(payload)).unwrap();
      const response = await fetch('/api/payments/initiate', { // Replace with your actual backend endpoint
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // Authorization header would be added by the API client middleware
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Failed to create payment intent on the server.');
      }

      return await response.json();
    } catch (error: any) {
      console.error('Failed to create payment intent:', error);
      toast.error(error.message || 'Could not initiate payment.');
      throw error;
    }
  }

  /**
   * Handles the payment confirmation step for Stripe using Stripe.js on the client-side.
   * This should be called after the user has entered their card details into a Stripe Element.
   * @param clientSecret - The client secret received from the backend via `createPaymentIntent`.
   * @param cardElement - The Stripe CardElement instance from your payment form.
   * @param paymentMethodData - Additional data, like billing details.
   * @returns A result object indicating success or failure.
   */
  public async handleStripePaymentConfirmation(
    clientSecret: string,
    cardElement: StripeCardElement,
    paymentMethodData: { billing_details: { name?: string; email?: string } }
  ): Promise<PaymentConfirmationResult> {
    if (!this.stripePromise) {
      return { success: false, error: { message: 'Stripe is not configured.' } };
    }
    const stripe = await this.stripePromise;
    if (!stripe || !cardElement) {
      return { success: false, error: { message: 'Stripe.js or card element not available.' } };
    }

    const { error, paymentIntent } = await stripe.confirmCardPayment(clientSecret, {
      payment_method: {
        card: cardElement,
        billing_details: paymentMethodData.billing_details,
      },
    });

    if (error) {
      console.error('Stripe payment confirmation error:', error);
      return { success: false, error: { code: error.code, message: error.message || 'An unknown error occurred.' } };
    }

    if (paymentIntent?.status === 'succeeded') {
      console.log('Stripe payment succeeded:', paymentIntent);
      // The backend should be notified via webhook, but you can also send a confirmation from the client.
      return { success: true, paymentIntentId: paymentIntent.id };
    }

    return { success: false, error: { message: `Payment not successful. Status: ${paymentIntent?.status}` } };
  }
  
  /**
   * Initiates the PayHere checkout process by invoking their JavaScript SDK.
   * @param payhereData - The payment parameters received from the backend.
   * @param customerDetails - Customer information required by PayHere.
   */
  public initiatePayHereCheckout(
    payhereData: {
      merchantId: string;
      orderId: string;
      amount: number;
      currency: string;
      hash: string;
    },
    customerDetails: {
      first_name: string;
      last_name: string;
      email: string;
      phone: string;
      address: string;
      city: string;
      country: string;
    }
  ): void {
    // This assumes the PayHere JS SDK is loaded on the page and exposes a global `payhere` object.
    const payhere = (window as any).payhere;
    if (!payhere) {
      console.error('PayHere JS SDK not found on window. Make sure the script is loaded.');
      toast.error('Could not connect to the payment gateway.');
      return;
    }

    const payment = {
      sandbox: import.meta.env.MODE === 'development', // Use sandbox in development environments
      merchant_id: payhereData.merchantId,
      return_url: `${window.location.origin}/payment/success?orderId=${payhereData.orderId}`,
      cancel_url: `${window.location.origin}/payment/cancelled`,
      notify_url: `${import.meta.env.VITE_API_BASE_URL}/payments/webhooks/payhere`, // Your backend webhook endpoint
      order_id: payhereData.orderId,
      items: 'YALURIDE Service Payment',
      amount: payhereData.amount.toFixed(2),
      currency: payhereData.currency,
      hash: payhereData.hash,
      ...customerDetails,
    };
    
    // Define callbacks for the PayHere SDK
    payhere.onCompleted = function (orderId: string) {
        console.log("PayHere Payment completed. OrderID:" + orderId);
        // The backend should confirm this via webhook. The frontend can redirect to a success page.
        // The success page should then verify the payment status with the backend.
        window.location.href = `/payment/success?orderId=${orderId}&gateway=payhere`;
    };

    payhere.onDismissed = function () {
        console.log("PayHere Payment dismissed by user.");
        toast.info("Payment process was cancelled.");
    };

    payhere.onError = function (error: any) {
        console.error("PayHere Error:", error);
        toast.error(`An error occurred during payment: ${error}`);
    };
    
    // Start the PayHere payment process
    payhere.startPayment(payment);
  }
}

// Export a singleton instance of the service for easy use across the application.
export const paymentGatewayService = new PaymentGatewayService();
